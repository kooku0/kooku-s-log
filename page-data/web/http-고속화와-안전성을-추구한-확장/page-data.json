{"componentChunkName":"component---src-templates-blog-post-js","path":"/web/http-고속화와-안전성을-추구한-확장/","result":{"data":{"site":{"siteMetadata":{"title":"Kooku's log","author":"Kooku","siteUrl":"https://kooku.netlify.com","comment":{"disqusShortName":"","utterances":"koomg9599/kooku-s-log"},"sponsor":{"buyMeACoffeeId":"kooku"}}},"markdownRemark":{"id":"3ee04f5b-e4ad-5016-b661-347ef39b0e48","excerpt":"리얼월드 HTTP  ‘4장 HTTP/1.1의 신택스: 고속화와 안전성을 추구한 확장’ 를 요약하였습니다. 이번에는 HTTP/1.1 이후에 추가된 새로운 기능을 설명하겠습니다. 이번에 다룰 내용은 다음과 같습니다. 통신 고속화 Keep-Alive가 기본적으로 유효하다. 파이프라이닝 TLS에 의한 암호화 통신을 지원한다. 새 메서드 추가 PUT과 DELETE가 필수 메서드가 됐다. OPTION, TRACE, CONNECT…","html":"<blockquote>\n<p>[리얼월드 HTTP]  ‘4장 HTTP/1.1의 신택스: 고속화와 안전성을 추구한 확장’ 를 요약하였습니다.</p>\n</blockquote>\n<p>이번에는 HTTP/1.1 이후에 추가된 새로운 기능을 설명하겠습니다.</p>\n<p>이번에 다룰 내용은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>통신 고속화</p>\n<ul>\n<li>Keep-Alive가 기본적으로 유효하다.</li>\n<li>파이프라이닝</li>\n</ul>\n</li>\n<li>TLS에 의한 암호화 통신을 지원한다.</li>\n<li>\n<p>새 메서드 추가</p>\n<ul>\n<li>PUT과 DELETE가 필수 메서드가 됐다.</li>\n<li>OPTION, TRACE, CONNECT 메서드가 추가됐다.</li>\n</ul>\n</li>\n<li>프로토콜 업그레이드</li>\n<li>이름을 사용한 가상 호스트를 지원</li>\n<li>크기를 사전에 알 수 없는 콘텐츠의 청크 전송 인코딩 지원</li>\n</ul>\n<h2 id=\"31-통신-고속화\" style=\"position:relative;\"><a href=\"#31-%ED%86%B5%EC%8B%A0-%EA%B3%A0%EC%86%8D%ED%99%94\" aria-label=\"31 통신 고속화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 통신 고속화</h2>\n<h3 id=\"311-keep-alive\" style=\"position:relative;\"><a href=\"#311-keep-alive\" aria-label=\"311 keep alive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1.1 Keep-Alive</h3>\n<p>Keep-Alive는 HTTP의 아래층인 TCP/IP 통신을 효율화하는 구조입니다. Keep-Alive를 사용하지 않으면 하나의 요청마다 통신을 닫아야 하지만, Keep-Alive를 사용하면 연속된 요청에는 접속을 다시 이용합니다. 이로써 TCP/IP는 접속까지의 대기 시간이 줄어들고, 통신 처리량이 많아지므로 속도가 올라간 것처럼 느껴집니다.</p>\n<img src=\"/d566c263f9d464e8419144112e4ba3f9/HTTP_persistent_connection.svg\">\n<p>HTTP/1.1에서는 이 동작이 기본으로 되어 있습니다. HTTP/1.0에서는 <code class=\"language-text\">Connection: Keep-Alive</code>를 헤더에 추가하여야 했습니다.</p>\n<p>뒤에 소개할 TLS 통신을 이용할 경우, 특히 통신 시간을 많이 줄여줍니다. HTTP 아래 계층의 프로토콜인 TCP/IP도 접속할 때는 1.5회 왕복의 통신을 필요로 합니다. 패킷이 1회 왕복하는 시간을 1RTT(round-trip time)로 부르며, TLS에서는 서버/클라이언트가 통신을 시작하기 전에 정보를 교환하는 handshake 과정에서 2RTT만큼 시간이 걸립니다. 이때 Keep-Alive를 이용하면, handshake 횟수를 줄일 수 있습니다. 게임 에셋을 다운로드할 때 1회 요청의 HTTP 통신을 반복한다고 가정하면, 두 번째 이후의 에셋 다운로드 시간을 최대 4RTT에서 1RTT로 줄일 수 있습니다.</p>\n<p>Keep-Alive를 이용한 통신은 클라이언트나 서버 중 한 쪽이 다음 헤더를 부여해 접속을 끊거나 타임아웃될 때까지 연결이 유지됩니다.</p>\n<p><code class=\"language-text\">Connection: Close</code></p>\n<p>통신 종료가 규정되어 있긴 하지만, 모든 통신이 확실히 끝났는지 서버가 판정할 수 없습니다. 따라서 HTML을 정적으로 해석하는 것 만으로는 클라이언트 측에서 모든 통신의 완료를 탐지할 수 없습니다. 그 때문에 서버에서 Keep-Alive 종료를 명시적으로 보내는 것이 간단하지 않고, 실제로는 타임아웃으로 접속이 끊어지기를 기다리게 됩니다.</p>\n<p>Keep-Alive 지속 시간은 클라이언트와 서버 모두 가지고 있습니다. 한쪽이 TCP/IP 연결을 끊는 순간에 통신은 완료되므로, 어느 쪽이든 짧은 쪽이 사용됩니다. 인터넷 익스플로러는 60s, 파이어폭스는 115s, Nginx는 75s, Apache는 5s 입니다.</p>\n<p>통신이 지속되는 동안 OS의 자원을 계속 소비하므로, 실제 통신이 이루어지지 않는데 접속을 유지하는 것은 바람직하지 않습니다.</p>\n<h3 id=\"312-파이프라이닝\" style=\"position:relative;\"><a href=\"#312-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B4%EB%8B%9D\" aria-label=\"312 파이프라이닝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1.2 파이프라이닝</h3>\n<p>파이프라이닝은 최초의 요청이 완료되기 전에 다음 요청을 보내는 기술입니다. 다음 요청까지의 대기 시간을 없앰으로써 네트워크 가동률을 높이고 성능을 향상시킵니다. Keep-Alive 이용을 전제로 하며, 서버는 요청이 들어온 순서대로 응답을 반환합니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 300px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 69.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACZUlEQVQ4y22TzUsUcRjHPzO/ednZ2ZfZdVfXVXNRQ4Ikz52ibpIoKZgEBV1aiiJ6QZBCQg+SFSZFJw8egsBTXYIoCYWIgoJOHfPQX9AbRDQ+87LruPjA9/ebmef7+z4v8/zgFuAL2tFlLQpKggOCisAmMJPIPgnqaPFbOuZ1Cgrsb5oLujj1QDQv0Jsuv5VrSTCtHVTAy+5+/4/BkkToZxiXclM6EhwUuAlRxZJWopchHKmpyTWEqx2SxwxsSFZbdFEvVbXyatbgr4nxxxA9FZTVRg98j0++Vi7vpMyzgx14K56Fb2hq24i9jklNS5SgIofhq7QQB/hQbONh0FNp6iM4nCz3pgVfJStf8C9d5kdHjrWOSHYmapPtklo2+tUrThnPqFt1ztgVep3AV1FRJ+6M5/C3oZz27Io2n5pgMz3Ci9JR3vf1sdIVko5zMdyHGc2P87Q8wLZt4zdSN5v5gwdT4fNBzmevc6n6gPnsfa5mbvDYyTCSiakD8V5MSQl6DKvKR6/EfDFRZ/9b9Kz87O6XdPddo15e4bl+joVGcNvi5J45sH/K8oZxtc4Fa5q5dIGxTMLvbKAZIphaxM3VcNTuzw9mykyFL8e4Eu5DTORPs1o6wZY9xje9tWQ9HImmGVEXgonuanyLBNfIhfo9uI7NZxHwheybBb7kPebCG+AxG3Inmyc1S0dXUSBtr2ByboJlk1H9LgvWFItulclwqGtMt3LNBj/ZsnD9hXIkw857lGq3uVyY5YmxzpoeXZbwvu5nTrIdsUUt+S0OEfSWMcszHFG7Jwq6XKlUVFbr2TAbtU8QdgABhGQFVgfJEgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"300px HTTP pipelining2 svg\" title=\"300px HTTP pipelining2 svg\" src=\"/static/b60b178f2c94770c2cad2c876779d150/5a46d/300px-HTTP_pipelining2.svg.png\" srcset=\"/static/b60b178f2c94770c2cad2c876779d150/12f09/300px-HTTP_pipelining2.svg.png 148w,\n/static/b60b178f2c94770c2cad2c876779d150/e4a3f/300px-HTTP_pipelining2.svg.png 295w,\n/static/b60b178f2c94770c2cad2c876779d150/5a46d/300px-HTTP_pipelining2.svg.png 300w\" sizes=\"(max-width: 300px) 100vw, 300px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>하지만 실제로 써봤지만 성능이 거의 좋아지지 않았다는 보고도 있고, 요청받은 순서대로 응답해야만 하므로, 응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 줍니다. 이는 HOL Blocking(head of line blocking)이라고 불리는 문제입니다.</p>\n<h2 id=\"32-전송-계층-보안tls\" style=\"position:relative;\"><a href=\"#32-%EC%A0%84%EC%86%A1-%EA%B3%84%EC%B8%B5-%EB%B3%B4%EC%95%88tls\" aria-label=\"32 전송 계층 보안tls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 전송 계층 보안(TLS)</h2>\n<p>HTTP/1.1과 병행해 통신 경로를 암호화하는 전송 계층 보안(Transport Layer Security)이 규격화됐습니다.  TLS는 기존 프로토콜에 통신 경로의 안전성을 추가해 새로운 프로토콜을 만들어낼 수 있는 범용적인 구조로 되어 있습니다. HTTP의 잘 알려진 포트는 80번이지만, HTTPS는 443번을 사용해 다른 서비스로 취급합니다.</p>\n<p>HTTP 통신을 중계하는 게이트웨이 입장에서 보면, ‘암호화되어 통신 내용을 엿보거나 변경할 수 없는 양방향 통신’입니다. TLS를 사용하면 조작할 수 없는 안정된 통신로가 생기므로, HTML5에서 새로 도입된 웹소켓 같은 통신 프로토콜이나 HTTP/2 등 HTTP/1.1 이전과 상위 호환성이 없는 수많은 새로운 시스템을 원만하게 도입하는 인프라가 됐습니다.</p>\n<p>TLS에는 몇 가지 버전이 있으며, SSL이라고 불리던 시절도 있습니다. 현재에도 TLS 부분을 맡은 라이브러리로서 높은 점유율을 자랑하는 소프트웨어 이름이 ‘OpenSSL’이라거나 서버를 보증하는 인증서에 ‘EV SSL’이라는 분류가 있는 등 SSL로 불리는 일이 많습니다. 다만 실제 SSL은 여러가지 취약성이 알려져 있어 RFC에서도 권장하지 않습니다. 인터넷 서비스에서도 무효화된 것이 많고, 실제로 사용되는 것은 대부분 TLS입니다.</p>","frontmatter":{"title":"HTTP 고속화와 안전성을 추구한 확장","date":"September 21, 2019"}}},"pageContext":{"slug":"/web/http-고속화와-안전성을-추구한-확장/","previous":{"fields":{"slug":"/web/http-브라우저-기본-성능의-이면/"},"frontmatter":{"title":"HTTP 브라우저 기본 성능의 이면","category":"web"}},"next":{"fields":{"slug":"/network/internetworking-&-ip/"},"frontmatter":{"title":"internetworking & IP","category":"network"}}}}}