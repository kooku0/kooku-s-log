---
title: HTTP 브라우저 기본 성능의 이면
date: 2019-09-21 14:09:78
category: web
---

>  [리얼월드 HTTP]  '2장 HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면' 를 요약하였습니다.

브라우저가 기본 요소들을 어떻게 응용하고 기본 기능을 실현하는지 살펴보겠습니다.



## 2.1 단순한 폼 전송(x-www-form-urlencoded)

Body에 `title=Head First PHP & MySQL&author=Lynn Beighley, Michael Morrison` 이라는 문자열을 보낸다고 해봅시다.

브라우저는 문자열을 그대로 연결합니다. 구분 문자인 &와 =이 있어도 그대로 연결해버리므로, 읽는 쪽에서 바르게 원래 데이터 세트로 복원할 수 없습니다.

따라서 브라우저는 **RFC 1866**에서 책정한 변환 포맷에 따라 변환을 실시합니다. 이 변환에서는 알파벳, 별표, 하이픈, 마침표, 언더스코어의 여섯 종류 문자 외에는 변환이 필요합니다. 공백은 +로 바뀌므로 실제로는 다음과 같이 됩니다.

`title=Head+First+PHP+%26+MySQL&author=Lynn+Beighley%2C+Michael+Morrison`

이 방식에서는 이름과 값 안에 포함되는 =와 &은 각각 %3D와 %26으로 변환됩니다. 실제 구분 문자는 변환되지 않으므로 읽는 쪽에서는 바르게 구분할 수 있습니다. 

프로그래머들은 이를 'URL 인코딩'으로 부릅니다.

## 2.2 Content Negotiation

서버와 클라이언트는 따로 개발되어 운용되므로 양쪽이 기대하는 형식이나 결정이 항상 일치한다고 할 수는 없습니다. 통신 방법을 최적화하고자 하나의 요청 안에서 서버와 클라이언트가 서로 최고의 설정을 공유하는 시스템이 content negotiation입니다. content negotiation에서는 header를 이용합니다.

negotiation할 대상과 사용하는 header는 아래 네 가지입니다. 

| 요청 헤더 | 응답              | negotiation 대상 |
| --------- | ----------------- | ---------------- |
| Accept    | Content-Type 헤더 | MIME 타입        |
| Accept-Language | Content-Language 헤더/html 태그 | 표시 언어 |
| Accept-Charset | Content-Type 헤더 | 문자의 문자셋 |
| Accept-Encoding | Content-Encoding 헤더 | 바디 압축 |

### 2.2.1 파일 종류 결정

---

`Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8`

---

이 헤더는 구글 크롬의 요청 헤더에서 가져왔습니다. 우선 콤마로 항목을 나눕니다.

* image/webp
* \*/\*;q=0.8

q는 품질 계수라는 것으로 0에서 1까지의 수치로 설정합니다. 기본으 1.0이고 이때는 q가 생략됩니다. 이 수치는 우선 순위를 나타냅니다.

클라이언트가 파일종류를 보냈을때 서버는 요청에서 요구한 형식 중에서 파일을 반환합니다. 우선 순위를 해석해 위에서부터 차례로 지원하는 포맷을 찾고, 일치하면 그 포맷으로 반환합니다. 만약 서로 일치하는 형식이 없으면 서버는 **406 Not Acceptable** 오류를 반환합니다.

### 2.2.2 표시 언어 결정

클라이언트가 지원하는 언어의 종류를 나타냅니다. 표시 언어도 기본은 같습니다. 영어로 우선 설정이 된 크롬은 다음 헤더를 각 요청에 부여합니다.

---

`Accept-Language: en-US, en; q=0.8, ko;q=0.6`

---

다시 말해, en-US, en, ko라는 우선 순위로 요청을 보냅니다. 언어 정보를 담는 상자로서 Content-Language 헤더가 있지만 대부분 이 헤더느 사용하지 않는 것 같습니다.

## 2.3 압축을 이용한 통신 속도 향상

콘텐츠 압축은 전송 속도 향상을 위한 것으로, 1992년 사양에서도 이미 정의되어 있었습니다. 콘텐츠 내용에 따라 다르지만, 현재 일반적으로 사용되는 압축 알고리즘을 적용하면 텍스트 파일은 1/10 크기로 압축됩니다. 가은 기호가 반복해서 나오는 JSON이라면 1/20 정도로 압축할 수 있습니다. 통신에 걸리는 시간보다 압축과 해제가 짧은 시간에 이루어지므로, 압축을 함으로써 웹페이지를 표시할 때 걸리는 전체적인 처리 시간을 줄일 수 있습니다. 다시 말해 브라우저 사용자에게는 전송 속도가 향상된 것처럼 보입니다.

콘텐츠 압축 negotiation은 모두 HTTP의 헤더 안에서 완료합니다. 우선 클라이언트가 수용 가능한 압축 방식을 헤더에서 지정합니다. 여기에서는 deflate와 gzip 두 가지를 지정했습니다.

`Accept-Encoding: deflate, gzip`

서버는 전송받은 목록 중 지원하는 방식이 있으면, 응답할 때 그 방식으로 압축하거나 미리 압축된 콘텐츠르 ㄹ반환합니다. 콘텐츠의 데이터양을 나타내는 Content-Length 헤더는 압축된 파일 크기입니다.

---

`Content-Encoding: gzip`

---

## 2.4 쿠키

쿠키란 웹사이트의 정보를 브라우저 쪽에 저장하는 작은 파일입니다. 서버가 클라이언트에 '이 파일을 보관해줘'라고 쿠키 저장을 지시합니다.

쿠키도 HTTP 헤더를 기반으로 구현됐습니다. 서버에서는 다음과 같이 응답 헤더를 보냅니다. 이 서버는 최종 액세스 날짜와 시간을 클라이언트에 저장하려고 합니다.

---

`Set-Cookie: LAST_ACCESS_DATE=jul/31/2016`

`Set-Cookie: LAST_ACCESS_TIME=12:04`

---

각각 '이름 = 값' 형식으로 회신했는데, 클라이언트는 이 값을 저장해둡니다. 다음번에 방문할 때는 다음과 같은 형식으로 보냅니다. 서버는 이 설정을 읽고, 클라이언트가 마지막으로 액세스한 시간을 알 수 있습니다.

---

`Cookie: LAST_ACCESS_DATE=jul/31/2016`

`Cookie: LAST_ACCESS_TIME=12:04`

---

HTTP는 stateless(언제 누가 요청해도 요청이 같으면 결과가 같음)를 기본으로 개발됐지만, 쿠키를 이용하면 (중단 지점부터 작업을 재개하는 등) 서버가 상태를 유지하는 statefull처럼 보이게 서비스를 제공할 수 있습니다.

### 2.4.1 쿠키의 문제점

쿠키는 편리한 기능이지만 몇 가지 문제점들이 있습니다.

1. 영속성의 문제

   쿠키는 어떤 상황에서도 확실하게 저장되는 것으 아닙니다. 다시 말해 서버가 쿠키를 DB 대신으로 쓸 수는 없습니다. 쿠키가 초기화되면 저장된 데이터는 사라집니다. 그러므로 사라지더라도 문제가 없는 정보나 서버 정보로 복원할 수 있는 자료를 저장하는 용도에 적합합니다.

2. 용량 문제

   쿠키의 최대 크기는 4kb 사양으로 정해져 있어 더 보낼 수는 없습니다. 쿠키는 헤더로서 항상 통신에 부가되므로 통신량이 늘어나는데, 통신량 증가는 요청과 응답 속도 모두에 영향을 미칩니다.

3. 보안 문제

   secure 속성을 부여하면 HTTPS 프로토콜로 암호화된 통신에서만 쿠키가 전송되지만, HTTP 통신에서는 쿠키가 평문으로 전송됩니다. 이때 민감한 정보가 노출될 위험이 있습니다. 암호화된다고 해도 사용자가 자유롭게 접근할 수 있는 것도 문제입니다. 원리상 사용자가 쿠키를 수정할 수도 있으므로, 민감한 정보를 넣는 데 적합하지 않으며 정보를 넣을 떄는 서명이나 암호화 처리가 필요합니다.

### 2.4.2 쿠키에 제약을 주다

쿠키를 제한하는 속성이 몇 가지 있습니다. HTTP 클라이언트는 이 속성을 해석해 쿠키 전송을 제어할 책임이 있습니다. 속성은 세미콜론으로 구분해 얼마든지 나열할 수 있습니다. 속성은 대문자와 소문자를 구별하지 않으므로 모두 소문자로 써도 유효합니다.

---

`Set-Cookie: SID=31d58degh30dkfhs; Path=/; Secure; HttpOnly`

`Set-Cookie: lang=en-US; Path=/; Domain=example.com`

---

* **Expires, Max-Age**: 쿠키의 수명을 정합니다. Max-Age는 초 단위로 지정, 현재 시각에서 지정된 초수를 더한 시간에서 뮤효가 됩니다.
* **Domain**: 클라이언트에서 쿠키를 전송할 대상 서버. 생략하면 쿠키를 발행한 서버의 경로입니다.
* **Path**: 클라이언트에서 쿠키를 전송할 대상 서버의 경로
* **Secure**: https로 프로토콜을 사용한 보안 접속일 때만 클라이언트에서 서버로 쿠키를 전송한다.
* **HttpOnly**: 쿠키를 소개할 때 쿠키를 자바스크립트로 다룰 수 있다고 설명했지만, 이 속성을 붙이면 JS 엔진으로부터 쿠키를 감출 수 있다. 크로스 사이트 스크립팅등 악의적인 자바스크립트가 실행되는 보안 위험에 대한 방어가 된다.
* **SameSite**: 이 속성은 RFC에서는 존재하지 않는다. 같은 출처의 도메인에 전송하게 된다.



## 2.5 캐시

웹 사이트의 콘텐츠가 점점 풍부해지자 한 페이지를 표시하는 데도 수십 개의 파일이 필요해졌고, 전체 용량도 메가바이트 단위로 늘어났습니다. 이렇게 늘어난 파일을 접속할 때마다 다시 다운해야 한다면 시간이 꽤 걸립니다. 그래서 콘텐츠가 변경되지 않았을 땐 로컬에 저장된 파일을 재사용함으로써 다운로드 횟수를 줄이고 성능을 높이는 '캐시' 메커니즘이 등장했습니다.

### 2.5.1 갱신 일자에 따른 캐시

우선 HTTP/1.0에서의 캐시를 설명합니다. 당시는 정적 콘텐츠 위주라서 콘텐츠가 갱신됐는지만 비교하면 충분했습니다.

`Last-Modified: Wed, 08 Jun 2016 15:23:45 GMT`

웹 브라우저가 캐시된 URL을 다시 읽을 때는 서버에서 변환된 일시를 그대로 If-Modified-Since 헤더에 넣어 요청합니다.

`If-Modified-Since: Wed, 08 Jun 2016 15:23:45 GMT`

웹 서버는 요청에 포함된 If-Modified-Since의 일시와 서버의 콘텐츠의 일시를 비교합니다. 변경됐으면 **200 OK** 코드를 반환하고 콘텐츠를 응답 바디에 실어서 보냅니다. 변경되지 않았으면, **304 Not Modified**를 반환하고 바디를 응답에 포함하지 않습니다.

### 2.5.2 Expires

Expires 헤더에는 날짜와 시간이 들어갑니다. 클라이언트는 지정한 기한 내라면 캐시가 *Fresh*하다고 판단해 강제로 캐시를 이용합니다. 다시말해 요청을 아예 전송하지 않습니다.

Expires를 사용하면 서버에 변경 사항이 있는지 묻지 않게 되므로 실시간 통신 서비스등에 사용할 때에는 주의해야 합니다. 지정된 기간 이내의 변경 사항은 모두 무시되어 새로운 컨텐츠를 전혀 볼 수 없기 때문입니다. 스타일시트 등 좀처럼 갱신되지 않느 정적 콘텐츠에 사용하는 것이 바람직합니다.

### 2.5.3 Pragma: no-cache

전항에서는 프록시를 이용한 캐시 기능을 소개했습니다. 한편 클라이언트가 프록시 서버에 지시할 수도 있습니다. 지시를 포함한 요청 헤더가 들어갈 곳으로서 HTTP/1.0부터 Pragma 헤더가 정의되어 있습니다. Pragma 헤더에 포함할 수 있는 페이로드로 유일하게 HTTP 사양으로 정의된 것이 no-cache입니다. 

no-cache는 '요청한 콘텐츠가 이미 저장돼 있어도, 원래 서버에서 가져오라'고 프록시 서버에 지시하는 것입니다. no-cache는 HTTP/1.1에 이르러 Cache-Control로 통합됐지만, 1.1 이후에도 하위 호환성 유지를 위해 남아 있습니다.