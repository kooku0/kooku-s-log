---
title: HTTP 기본이 되는 네 가지 요소
date: 2019-09-21 12:09:14
category: web
---

>  [리얼월드 HTTP]  '1장 HTTP/1.0의 신택스: 기본이 되는 네 가지 요소' 를 요약하였습니다.

HTTP의 네 가지 기본 요소는 밑의 네 가지라고 할 수 있습니다.

* Meathod & Path
* Header
* Body
* Status Code

이 네 가지 기본 요소에 초점을 맞춰 설명하겠습니다.

## 1.1 HTTP의 역사

HTTP는 웹 브라우저로 웹페이지를 표시할 때 서버로부터 정보를 받아오는 약속(프로토콜)이지만, 그 범위를 넘어서 *Restful API*로도 사용되면서 현재 인터넷의 기초가 됐습니다. HTTP는 1990년 최초로 실제 동작 가능한 구현과 개요가 공개된 이후 계속 버전 업이 이루어졌습니다.

* 1990년: HTTP/0.9
* 1996년: HTTP/1.0
* 1997년: HTTP/1.1
* 2005년: HTTP/2

최초 버전인 HTTP/0.9는 HTML 도큐먼트를 요청해서 가져오기만 하는 단순한 프로토콜이었습니다. 그 후로 폼을 전송하거나 정보를 갱신하기도 하고, 채팅 기능 구현에 사용되는 등 유연성을 보이면서 새로운 기능이 필요할 때마다 확장됐습니다.

## 1.2 Header

HTTP의 헤더는 요청과 응답 양쪽에서 사용됩니다. 원래 이 아이디어는 인터넷이 보급되기 전 부터 사용자 간 정보 교환으로 사용되던 메일 시스템에서 왔습니다.

헤더는 **'파일명: 값'** 형식으로 본문 앞에 부가됩니다. 각 헤더는 한 줄에 하나씩 기술되어 있고, 본문과의 사이에는 빈 줄이 하나 있습니다. 또한 헤더 이름은 대문자, 소문자를 구별하지 않습니다.

헤더는 서버와 클라이언트 사이에 필요한 추가 정보, 지시나 명령 당부 등을 쓰는 장소입니다. 헤더는 종류가 많으므로 알기 쉬운 것을 일부 골랐습니다. 우선은 클라이언트가 서버에 보내는 헤더입니다.

* User-Agent: 클라이언트가 자신의 애플리케이션 이름을 넣는 곳. 서버는 이곳의 이름을 보고 응답을 전환하기도 한다. 피처폰이나 스마트폰, PC의 경우도 브라우저의 종류나 버전을 구분할 수 있다.
* Referer: 서버에서 참고하는 추가 정보. 클라이언트가 요청을 보낼 때 보고 있던 페이지의 URL을 보낸다. 페이지의 참조원을 서버가 참조하는 데 이용한다. 보안 때문에 사양이 당초보다 크게 변경됐다.
* Authorization: 특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에게 전달한다. token등을 담아서 보낸다.
* Content-Type: 파일 종류를 지정. 여기에는 MIME 타입이라는 식별자를 기술한다.
* Contnet-Length: 바디 크기.
* Content-Encoding: 압축이 이루어진 경우 압축 형식을 설명한다.
* Date: 문서 날짜

또한 이 밖에 X-로 시작되는 헤더는 각 애플리케이션이 자유롭게 사용해도 좋다고 되어 있습니다.

### 1.2.1 MIME 타입

MIME 타입은 파일의 종류를 구별하는 문자열로, 전자메일을 위해 만들어졌습니다. 처음 등장한 것은 1992년 **RFC 1341**입니다.

일반적으로 보급된 웹사이트는 HTML 파일을 바탕으로 사진이나 음악을 붙인 것이 대부분입니다. 요즘 같으면 JS나 CSS를 사용한 풍부한 사용자 경험을 제공하는 것도 거의 필수지요. 브라우저는 OS와 별도로 파일 종류별로 어떤 동작을 할지 관리합니다. 이때 파일 종류를 나타내는 식별자가 MIME입니다.

현재 웹 서버에서 HTML을 보낼 경우는 서버의 응답 헤더에 다음과 같은 MIME 타입을 설정합니다.

---

`Contnet-Type: text/html; charset=utf-8`

---

MIME 타입의 *RFC*는 그 후에도 여러 가지가 추가되고 갱신됐습니다. 인터넷에서는 JSON이나 XML 같은 범용 포맷을 특정 용도로 사용하는 경우가 있습니다. 이때 사용하는 접미사도 **RFC 2030**에서 추가되었습니다. 이로써 XML을 기반으로 한 SVG 이미지를 application/xml이 아니라 더욱 구체적으로 image/svg+xml로 표기할 수 있게 됐습니다.

> **RFC** (Request For Comments)
>
> *IETF*가 만든 규약 문서

### 1.2.2 Content-Type과 보안

브라우저 세계에서는 앞에서 소개한 것처럼 파일 종류를 특정할 때 Content-Type 헤더에서 지정된 MIME 타입을 사용합니다.

인터넷 익스플로러는 인터넷 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측하려고 합니다. 이런 동작을 콘텐트 스트핑(content sniffing)이라고 합니다. 이때 서버 설정이 잘못된 경우에도 제대로 표시되므로 얼핏 사용자에게 장점이 있는 것처럼 여겨질 수 있습니다. 하지만 원래 텍스트로 표시돼야 하는 text/pain 파일인데도 HTML과 자바스크립트가 적혀 있으면 브라우저가 파일을 실행해버리는 일도 있었습니다. 뜻밖에 보안의 구멍이 될 수 있습니다.

서버에서 다음과 같은 헤더를 전송해 브라우저가 추측하지 않도록 지시하는 것이 현재 주류의 방법입니다.

---

`X-Content-Type-Options: nosniff`

---

## 1.3 Meathod

HTTP Meathod의 경우는 파일 시스템 같은 설계 철학으로 만들어졌습니다. 아리 세 가지 메서드가 흔히 쓰이는 메서드 입니다.

* **GET**: 서버에 헤더와 콘텐츠 요청
* **HEAD**: 서버에 헤더만 요청, 웹 서버의 다운 여부, 점검이나 웹 서버 정보 등을 얻기 위해 사용.
* **POST**: 새로운 문서 투고

아래 두 메서드는 1.0 이후에도 살아남았지만, 1.0 단계에서는 필수가 아니라 구현에 따라 제공되기도 하고 제공되지 않기도 하는 옵션 기능입니다. 실제 브라우저가 표준 기능만으로 이들 메서드로 서버에 요청을 보낼 수 있게 된 것은 훨씬 나중의 일로, 자바스크립트에서 **XML HttpRequest**가 지원되고 나서부터입니다.

*HTML의 폼에서는 GET과 POST만 지원됩니다.*

* **PUT**: 이미 존재하는 URL의 문서를 갱신한다.
* **DELETE**: 지정된 URL의 문서를 삭제한다. 삭제에 성공하면 삭제된 URL은 무효가 된다.

HTTP/1.1에서 몇 개가 더 추가되었습니다.

* **OPTIONS**: 웹서버에서 지원되는 메소드의 종류를 확인할 경우 사용.
* **CONNECT**: 웹 서버에 proxy 기능을 요청할 때 사용.
* **TRACE**: 서버에 Loopback 메세지를 호출하기 위해 사용.

## 1.4 Status Code

Status Code는 세 자리 숫자를 보고 서버가 어떻게 응답했는지 한 눈에 알 수 있습니다. 크게 다섯 가지 카테고리로 나눌 수 있습니다.

* 100번대: 처리가 계속됨을 나타낸다. 1xx 계열은 특수한 용도로 사용된다.
* 200번대: 성공했을 떄의 응답. 자주 사용되는 *status code*는 **200 OK**로 정상 종료를 나타낸다.
* 300번대: 서버에서 클라이언트로의 명령. 오류가 아니라 정상 처리의 범주. *redirect*나 *cache* 이용을 지시한다.
* 400번대: 클라이언트가 보낸 요청에 오류가 있다.
* 500번대: 서버 내부에서 오류가 발생했다.

### 1.4.1 Redirect

300번대 status의 일부는 서버가 브라우저에 대해 *redirect*하도록 지시하는 *status code*입니다. 300 이외의 경우 *Location* 헤더를 사용해 redirect할 곳을 서버에서 클라이언트로 전달합니다. redirect에는 다섯 가지 종류가 있습니다.

| status code            | 영구적/ 일시적 | 설명                              |
| ---------------------- | -------------- | --------------------------------- |
| 301 Moved Permanently  | 영구적         | 도메인 전송, 웹사이트 이전, HTTPS |
| 302 Found              | 일시적         | 일시적 관리, 모바일 기반 전송     |
| 303 See Other          | 영구적         | 로그인 후 페이지 전환             |
| 307 Temporary Redirect | 일시적         | RFC 7231에서 추가                 |
| 308 Moved Permanently  | 영구적         | RFC 7538에서 추가                 |

영구적인지 일시적인지는 이동하는 페이지가 이후에도 존재하는지로 분류합니다. 새 도메인을 얻어 서버의 콘텐츠를 이동한 경우나 HTTP로 운영되던 페이지를 HTTPS로 전환한 경우에는 예전 페이지를 볼 일이 없습니다. 이때는 영구적인 redirect가 됩니다. 점검 기간에만 요청을 관리 화면으로 redirect할 경우는 점검이 끝나면 복구해 다시 활성화할 것이므로 일시적인 redirect를 사용합니다.

클라이언트는 *Location* 헤더 값을 보고, 다시 요청합니다. 재전송할 때는 헤더 등도 다시 보냅니다.

redirect에는 단점도 있습니다. redirect하는 곳이 다른 서버라면 redirect할 때마다 TCP 세션 접속, HTTP 송수신으로 두 번 왕복 통신이 발생합니다. redirect 수가 늘어나면, 그만큼 표시에 걸리는 시간이 늘어납니다. 구글은 redirect 횟수는 5회 이하. 가능하면 3회 이하로 가이드라인을 제시했습니다.

redirect 횟수는 --max-redirs 옵션으로 지정할 수 있습니다.

## 1.5 URL

URI 와 URL을 자주 혼동하지만, URI에는 URN(Uniform Resource Name)이라는 이름 부여 규칙도 포함됩니다. URL은 장소로 문서 등의 리소스를 특정하는 수단을 제공합니다. 요컨데 주소입니다. URN은 이름 그 자체입니다.

예를 들어 '무궁화2호'라는 전철이 있다고 하면, 'urn:KR:무궁화2호'라는 규칙으로 붙인 이름이 URN입니다.

'전차://부산역/6번홈/무궁화2호'는 URL입니다. 전차가 달려서 서울역으로 가버리면, URL로는 무궁화2호에 접속할 수 없습니다. URN은 이름밖에 없으므로 어디에 있는지 알려면 따로 정보가 필요합니다.

웹 시스템을 다루는 한 URN이 등장할 일은 없으므로 URL과 URI는 거의 같습니다. 이후에 **RFC 3305**에서 URL은 관용 표현으로 공식 표현은 URI가 됐지만 URL이 일반적으로 널리 사용됩니다. HTML5에 관해 논의 하는 W3C는 세부적인 사양이나 자바스크립트 API 사양을 정한 표준화를 시행하고 있지만, 이쪽에서의 이름은 URL로 됐습니다.

### 1.5.1 URL의 구조

일반적으로 자주 보는 URL은 다음과 같은 형식입니다.

---

`https://www.naver.com/index.html`

---

이 URL은 아래와 같은 요소로 구성됩니다.

**스키마://호스트명/경로**

이 규칙을 따라 요소를 분해하면, 각 항목은 다음과 같은 요소가 됩니다.

* 스키마: https
* 호스트명: www.naver.com
* 경로: index.html

> 흠.. 저는 스키마가 아닌 프로토콜이라고 알고있는데 무엇이 맞는지 잘모르겠군요.

URL 사양에 포함되는 모든 요소가 들어간 예제는 다음과 같은 형식이 됩니다.

**스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리**

스카마 해석은 브라우저의 책임입니다. 브라우저는 스키마를 보고 적절한 접속 방법을 선택해야 합니다. 실제로 통신하는 곳은 **호스트명**으로 지정된 서버입니다.

포트는 아파트 등의 우편함 같은 것입니다. IP마다 65,535개의 포트가 있습니다.

같은 주소라도 포트가 다르면 독립적으로 복수의 서버를 운영해 서비스를 제공할 수 있습니다.

포트가 생략되면 스키마별 기본 포트를 사용합니다. HTTP라면 80, HTTPS라면 443.

사용자 이름과 패스워드는 FTP 등에서 사용됩니다.

프래그먼트는 HTML에서는 페이지 내 앵커를 지정하는 데 쓰입니다.

쿼리는 검색 용어를 지정하거나 표시하고 싶은 웹페이지에 대해서 특정 파라미터를 부여하는데 사용합니다.

## 1.5 Body

HTTP/0.9 사양에서는 요청에 데이터를 포함할 수 없었습니다. 응답은 파일 콘텐츠 자체였지만, 1.0에서는 요청과 응답 양쪽에 헤더가 포함돼 바디와 헤더를 분리할 필요가 있었습니다. 또한 요청에도 콘텐츠를 포함할 수 있게 돼 새로운 역할이 늘어났습니다.

HTTP에서 응답의 바디는 단순합니다. 한 번 응답할 때마다 한 파일만 반환하기 때문입니다. HTTP의 바디를 다루는 프로그램을 작성할 때도 응답의 본체를 지정한 바이트 수만큼 읽어 오면 그만입니다. 읽어 올 바이트 수는 Content-Length 헤더로 지정합니다.

속도를 위해 바디를 압축하는 경우가 있습니다. 이때는 Content-Encoding에서 지정된 압축 알고리즘으로 읽어 온 바디의 데이터를 전개할 필요가 있습니다. 이 경우 Contnet-Length는 압축 전 콘텐츠 길이가 아니라 압축 후 통신 데이터 크기 입니다.

HTTP의 메서드 중에서 바디를 포함하느 것이 '기대되지 않는' 메서드가 있습니다.

바로 GET인데요. HTTP/1.1의 저자 중 한 사람인 로이 필딩의 메세지를 인용하겠습니다.

> 어떤 HTTP 요청 메시지라도 메시지 Body 포함이 허용되며 이를 염두에 두고 해겨할 필요가 있습니다. 그러나 서버는 GET의 바디가 있어도 요청에 대해 뭔가 의미를 얻지 못하게 제한됩니다.
>
> 즉,  GET에 Body를 포함하여 보낼 수 있지만, 그렇게 하는 것이 결코 유용하진 않습니다.